-- =====================================================
-- EAI E-Learning Platform - Functions & Triggers
-- =====================================================

-- =====================================================
-- 1. Auto-update updated_at timestamp
-- =====================================================

CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply to all tables with updated_at column
CREATE TRIGGER update_profiles_updated_at
  BEFORE UPDATE ON profiles
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_courses_updated_at
  BEFORE UPDATE ON courses
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_modules_updated_at
  BEFORE UPDATE ON modules
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_lessons_updated_at
  BEFORE UPDATE ON lessons
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_assessments_updated_at
  BEFORE UPDATE ON assessments
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_questions_updated_at
  BEFORE UPDATE ON questions
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- =====================================================
-- 2. Validate max attempts before inserting attempt
-- =====================================================

CREATE OR REPLACE FUNCTION check_attempt_limit()
RETURNS TRIGGER AS $$
DECLARE
  attempts_count INTEGER;
  max_attempts INTEGER;
BEGIN
  -- Get current attempt count
  SELECT COUNT(*)
  INTO attempts_count
  FROM assessment_attempts
  WHERE student_id = NEW.student_id
    AND assessment_id = NEW.assessment_id;

  -- Get max attempts allowed
  SELECT assessments.max_attempts
  INTO max_attempts
  FROM assessments
  WHERE id = NEW.assessment_id;

  -- Check if limit exceeded
  IF attempts_count >= max_attempts THEN
    RAISE EXCEPTION 'Maximum number of attempts (%) exceeded', max_attempts;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER check_attempt_limit_trigger
  BEFORE INSERT ON assessment_attempts
  FOR EACH ROW EXECUTE FUNCTION check_attempt_limit();

-- =====================================================
-- 3. Auto-generate certificate on course completion
-- =====================================================

CREATE OR REPLACE FUNCTION check_course_completion()
RETURNS TRIGGER AS $$
DECLARE
  course_id_var UUID;
  total_lessons INTEGER;
  completed_lessons INTEGER;
  certificate_exists BOOLEAN;
BEGIN
  -- Get the course_id for this lesson
  SELECT courses.id
  INTO course_id_var
  FROM lessons
  JOIN modules ON modules.id = lessons.module_id
  JOIN courses ON courses.id = modules.course_id
  WHERE lessons.id = NEW.lesson_id;

  -- Count total lessons in the course
  SELECT COUNT(lessons.id)
  INTO total_lessons
  FROM lessons
  JOIN modules ON modules.id = lessons.module_id
  WHERE modules.course_id = course_id_var;

  -- Count completed lessons by this student
  SELECT COUNT(lesson_progress.id)
  INTO completed_lessons
  FROM lesson_progress
  JOIN lessons ON lessons.id = lesson_progress.lesson_id
  JOIN modules ON modules.id = lessons.module_id
  WHERE modules.course_id = course_id_var
    AND lesson_progress.student_id = NEW.student_id;

  -- Check if certificate already exists
  SELECT EXISTS(
    SELECT 1 FROM certificates
    WHERE student_id = NEW.student_id
      AND course_id = course_id_var
  ) INTO certificate_exists;

  -- If all lessons completed and no certificate exists, create one
  IF completed_lessons >= total_lessons AND NOT certificate_exists THEN
    INSERT INTO certificates (student_id, course_id, certificate_url)
    VALUES (NEW.student_id, course_id_var, NULL); -- URL will be generated by app
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER check_course_completion_trigger
  AFTER INSERT ON lesson_progress
  FOR EACH ROW EXECUTE FUNCTION check_course_completion();

-- =====================================================
-- 4. Create profile on user signup
-- =====================================================

CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO profiles (id, email, full_name, role)
  VALUES (
    NEW.id,
    NEW.email,
    COALESCE(NEW.raw_user_meta_data->>'full_name', ''),
    COALESCE(NEW.raw_user_meta_data->>'role', 'student')
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION handle_new_user();

-- =====================================================
-- 5. Helper function to get student progress percentage
-- =====================================================

CREATE OR REPLACE FUNCTION get_student_progress(
  p_student_id UUID,
  p_course_id UUID
)
RETURNS INTEGER AS $$
DECLARE
  total_lessons INTEGER;
  completed_lessons INTEGER;
  progress_percentage INTEGER;
BEGIN
  -- Count total lessons in course
  SELECT COUNT(lessons.id)
  INTO total_lessons
  FROM lessons
  JOIN modules ON modules.id = lessons.module_id
  WHERE modules.course_id = p_course_id;

  -- Return 0 if no lessons
  IF total_lessons = 0 THEN
    RETURN 0;
  END IF;

  -- Count completed lessons
  SELECT COUNT(lesson_progress.id)
  INTO completed_lessons
  FROM lesson_progress
  JOIN lessons ON lessons.id = lesson_progress.lesson_id
  JOIN modules ON modules.id = lessons.module_id
  WHERE modules.course_id = p_course_id
    AND lesson_progress.student_id = p_student_id;

  -- Calculate percentage
  progress_percentage := (completed_lessons * 100) / total_lessons;

  RETURN progress_percentage;
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- 6. Helper function to get student stats
-- =====================================================

CREATE OR REPLACE FUNCTION get_student_stats(p_student_id UUID)
RETURNS TABLE (
  enrolled_courses INTEGER,
  completed_courses INTEGER,
  total_certificates INTEGER,
  avg_assessment_score NUMERIC,
  total_assessments_passed INTEGER
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    (SELECT COUNT(*) FROM enrollments WHERE student_id = p_student_id)::INTEGER,
    (SELECT COUNT(*) FROM certificates WHERE student_id = p_student_id)::INTEGER,
    (SELECT COUNT(*) FROM certificates WHERE student_id = p_student_id)::INTEGER,
    (SELECT COALESCE(AVG(score), 0)::NUMERIC FROM assessment_attempts WHERE student_id = p_student_id),
    (SELECT COUNT(*) FROM assessment_attempts WHERE student_id = p_student_id AND passed = TRUE)::INTEGER;
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- 7. Helper function to grade assessment
-- This should be called from the application for security
-- but we provide it as a utility
-- =====================================================

CREATE OR REPLACE FUNCTION grade_assessment(
  p_assessment_id UUID,
  p_answers JSONB
)
RETURNS TABLE (
  score INTEGER,
  passed BOOLEAN,
  total_questions INTEGER,
  correct_answers INTEGER
) AS $$
DECLARE
  v_total INTEGER;
  v_correct INTEGER;
  v_score INTEGER;
  v_passing_score INTEGER;
  v_passed BOOLEAN;
BEGIN
  -- Count total questions
  SELECT COUNT(*) INTO v_total
  FROM questions
  WHERE assessment_id = p_assessment_id;

  -- Count correct answers
  SELECT COUNT(*) INTO v_correct
  FROM questions
  WHERE assessment_id = p_assessment_id
    AND correct_answer = (p_answers->>id::TEXT);

  -- Calculate score percentage
  IF v_total > 0 THEN
    v_score := (v_correct * 100) / v_total;
  ELSE
    v_score := 0;
  END IF;

  -- Get passing score
  SELECT passing_score INTO v_passing_score
  FROM assessments
  WHERE id = p_assessment_id;

  -- Determine if passed
  v_passed := v_score >= v_passing_score;

  RETURN QUERY SELECT v_score, v_passed, v_total, v_correct;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
